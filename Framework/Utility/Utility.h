//__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/
//! @file   Utility.h
//!
//! @brief  実用関数のヘッダファイル
//!
//! @date   2014/10/10
//!
//! @author 高木 晋
//__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/__/

// 多重インクルード防止 ====================================================
#pragma once




// インライン関数の定義 ====================================================
//------------------------------------------------------------------
//! @brief 動的に確保されたメモリ領域の解放
//!
//! @param[in] pointer 解放対象のメモリ領域のアドレス
//!
//! @return なし
//------------------------------------------------------------------
template <typename T>
inline void SafeDelete(T*& pointer)
{
	delete pointer;
	pointer = nullptr;
}


//------------------------------------------------------------------
//! @brief 動的に確保された配列の解放
//!
//! @param[in] pointer 解放対象の配列の先頭アドレス
//!
//! @return なし
//------------------------------------------------------------------
template <typename T>
inline void SafeDeleteArray(T*& pointer)
{
	delete[] pointer;
	pointer = nullptr;
}



//------------------------------------------------------------------
//! @brief インターフェイスの参照カウントを 1 ずつ減少させる
//!
//! @param[in] target 減少対象のインターフェース
//!
//! @return なし
//------------------------------------------------------------------
template <typename T>
inline void SafeRelease(T*& target)
{
	if (target)
	{
		target->Release();
		target = nullptr;
	}
}



//------------------------------------------------------------------
//! @brief 静的配列の要素数の取得
//!
//! @param[in] 要素数を調べたい配列
//!
//! @return 静的配列の要素数
//------------------------------------------------------------------
template <typename T, size_t SIZE>
inline size_t ArraySize(const T(&)[SIZE])
{
	return SIZE;
}
